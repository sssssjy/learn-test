# 计时器

## jest.spyOn

模拟对象或者类的方法 监控这些方法的调用情况

```ts
cons myApi = {
    async fetchUser(id) {
        const response = await fetct(`/api/user/${id}`)
        const user = await response.json()
        return user;
    }
};

test('fetch user data', aysnc () => {
    // 监视myApi的fetchUser方法
    const spy = jest.spyOn(myApi, 'fetchUser');
    // 通过spy重新定义该方法的返回值
    // 达到更好的控制

    spy.mockResolvedValue({name: 'john', age: 30});

    const user = await myApi.fetchUser(123);

    expect(user).toEqual({name: 'john', age: 30});
    expect(spy).toHaveBeenCalledWith(123);

    spy.mockRestore();
})
```

jest.spyOn与jest.mock的区别

- jest.spyOn 用于监视对象的方法 帮助监视测试代码中的某个方法是否被调用 另外还可以控制所监视方法的行为
- jest.mock 用于模块的导入 可以帮助在测试中替换掉被测试代码中所依赖的模块

## 模拟setInterval

当测试代码包含setInterval这样的计时器代码时 往往需要调用jest.useFakeTimers方法
该方法的作用是提供了一个模拟计时器对象 这样在测试过程中不需要使用真实的计时器
使用模拟计时器对象 最大的好处是 模拟时间的流逝

在使用模拟计时器之后需要重新使用真实计时器

```ts
import {startTimer, stopTimer} from '../ts/tools';
type Timer = ReturnType<typeof setInterval>;

beforeEach(() => {
    // 在每个测试用例开始之间使用模拟计时器
    jest.useFakeTimers();
});

afterEach(() => {
    // 在每个测试用例结束后恢复真实计时器
    jest.useRealTimers();
});

test('开始计时器', () => {
    const callback = jest.fn();
    const interval = 1000;

    const setInterval = jest.spyOn(window, 'setInterval'); // 避免调用真实的 setInterval

    const timerId = startTimer(() => {
        callback();
    }, interval) as unknown as number;

    // 使用各种断言进行测试

    // 调用了startTimer方法后 setInterval 应该被调用一次
    expect(setInterval).toHaveBeenCalledTimes(1);
    // 断言 setInterval 调用时的参数
    expect(setInterval).toHaveBeenCalledWith(expect.any(Function), interval);

    jest.advanceTimersByTime(1000); // 快进 1s

    expect(callback).toHaveBeenCalledTimes(1); // 回调函数应该被调用一次

    jest.advanceTimersByTime(3000); // 再快进 3s

    expect(callback).toHaveBeenCalledTimes(4); // 回调函数应该被调用四次
    expect(setInterval).toHaveBeenCalledTimes(1);
    stopTimer(timerId as unknown as Timer);
})

test('停止计时器', () => {
    const callback = jest.fn();
    const interval = 1000;

    const timerId = startTimer(callback, interval) as unknown as number;
    stopTimer(timerId as unknown as Timer);

    expect(callback).toHaveBeenCalledTimes(0); // 回调函数不应该被调用
    expect(callback).not.toHaveBeenCalled();
})
```

- 通过调用`jest.useFakeTimers();`使用模拟的计时器对象 可以控制时间的流逝
- 通过调用`jest.useRealTimers();`将模拟的计时器对象还原为真实的计时器对象
- 使用`jest.spyOn`监听替换setInterval 避免调用真实的setInterval

## 模拟setTimeout

```ts
test("开启延时器", () => {
    const callback = jest.fn();
    const delay = 3000;
    const setTimeOut = jest.spyOn(window, 'setTimeout'); // 避免调用真实的 setTimeout

    const timerId = startTimeOut(callback, delay) as unknown as Timer;
    
    // 使用各种断言进行测试
    expect(setTimeOut).toHaveBeenCalledTimes(1);

    expect(callback).toHaveBeenCalledTimes(0); // 回调函数不应该被调用
    jest.advanceTimersByTime(1000); // 快进 1s
    expect(callback).toHaveBeenCalledTimes(0); // 回调函数不应该被调用
    jest.advanceTimersByTime(1000); // 快进 1s
    expect(callback).toHaveBeenCalledTimes(0); // 回调函数不应该被调用
    jest.advanceTimersByTime(1000); // 快进 1s
    expect(callback).toHaveBeenCalledTimes(1); // 回调函数应该被调用一次
});

test("停止延时器", () => {
    const callback = jest.fn();
    const delay = 3000;

    const setTimeOut = jest.spyOn(window, 'setTimeout'); // 避免调用真实的 setTimeout

    const timerId = startTimeOut(callback, delay) as unknown as Timer;
    stopTimeOut(timerId);

    expect(setTimeOut).toHaveBeenCalledTimes(1);
    expect(callback).toHaveBeenCalledTimes(0); // 回调函数不应该被调用
    jest.advanceTimersByTime(3000); // 快进 3s
    expect(callback).toHaveBeenCalledTimes(0); // 回调函数不应该被调用
    expect(callback).not.toHaveBeenCalled();
});

test("时间不可为负数", () => {
    const callback = jest.fn();
    const delay = -3000;

    const setTimeOut = jest.spyOn(window, 'setTimeout'); // 避免调用真实的 setTimeout

    const timerId = startTimeOut(callback, delay) as unknown as Timer;
    stopTimeOut(timerId);

    expect(setTimeOut).toHaveBeenCalledTimes(0);
    expect(callback).toHaveBeenCalledTimes(0); // 回调函数不应该被调用
    jest.advanceTimersByTime(3000); // 快进 3s
    expect(callback).toHaveBeenCalledTimes(0); // 回调函数不应该被调用
    expect(callback).not.toHaveBeenCalled();
});
```
