# 模拟模块

模块可以分为两个模块：

- 第三方模块
- 文件模块

## 模拟第三方模块

jest.mock(moduleName, factory, options)

在项目中的请求必然涉及使用axios/fetch等库 此时想屏蔽请求
若使用模拟方法 无法测试方法内部实现是否正确
因此可以使用模拟axios/fetch模块的方式来屏蔽发送请求的部分

使用jest.mock方法模拟axios
在测试用例中指定axios.get方法的行为 之后对user.all方法进行测试

```ts
class User {
    static all = () => {
        // 获取所有的用户
        return axios.get("/users.json").then((resp: { data: any; }) => resp.data);
    }
}

const axios = require('axios');
const User = require('../api/user');
const userData = require('./user.json');

// 模拟axios模块
jest.mock('axios');

// 测试用例
test('测试获取用户数据', async () => {
    // 模拟响应数据
    const resp = {data: userData};
    
    // 指定模拟axios行为
    // 在使用axios.get时 相应resp
    axios.get.mockImplementation(() => Promise.resolve(resp));
    await expect(User.all()).resolves.toEqual(userData);
});
```

也可以传入工厂函数指定行为

```ts
// 模拟axios模块
jest.mock('axios', () => {
    const userData = require('./user.json');
    const resp = {data: userData};
    return {
        get: jest.fn(() => Promise.resolve(resp))
    }
});

// 测试用例
test('测试获取用户数据', async () => {
    await expect(User.all()).resolves.toEqual(userData);
});
```

## 模拟文件模块

对文件进行模拟 替换部分内容

```ts
const {sum, multiply, divide, subtract} = require("../utils/tool");

jest.mock("../utils/tool", () => {
    // 改写文件模块实现

    // 拿到指定路径下的文件原始模块
    const originalModule = jest.requireActual("../utils/tool");

    // 相当于替换原始模块
    // 一部分使用原始模块，一部分使用模拟实现
    return {
        ...originalModule,
        sum: jest.fn(() => 10),
        multiply: jest.fn(() => 20),
    }
});

test("测试工具模块的函数", () => {
    // 测试被改写的函数
    expect(sum(1, 2)).toBe(10);
    expect(multiply(2, 3)).toBe(20);

    // 测试未被改写的函数
    expect(divide(6, 2)).toBe(3);
    expect(subtract(5, 3)).toBe(2);
});
```

在运行多个测试套件时 默认不会显示每个测试套件的描述
可添加配置

```ts
"test": "jest --verbose=true",
```
